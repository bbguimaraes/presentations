\documentclass{beamer}
\mode<presentation>{
    \usetheme{Madrid}
    \setbeamertemplate{footline}{}
    \setbeamertemplate{navigation symbols}{}}

\usepackage[utf8]{inputenc}
\usepackage{varwidth}
% Allows including images.
\usepackage{graphicx}
\setcounter{tocdepth}{2}
%% Display notes.
%\usepackage{pgfpages}
%\setbeameroption{show notes on second screen}
% Stop messing with my single quotes!
\usepackage{upquote}
% Multi-column itemize.
\usepackage{multicol}

\newcommand{\autotitle}
{\frametitle{
    \secname
    \ifx\insertsubsection\empty
    \else
        /\subsecname
        \ifx\insertsubsubsection\empty\else/\subsubsecname\fi
    \fi}}

\title{Linux containers}

\author{Bruno Barcarol Guimarães}
\institute[]{\textit{bbguimaraes.com}}
\date{2015-07-10}

\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\section{overview}

\begin{frame}
    \autotitle
    \tableofcontents
\end{frame}

\subsection{pre-history}

\begin{frame}
    \autotitle
    \begin{quote}
        You have probably heard about Docker and Containers, but FreeBSD
        have had jails since I wrote them in 1998.
    \end{quote}
    Poul-Henning Kamp
    \cite{kamp_varnish}
\end{frame}

\subsubsection{time-sharing}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item
            First appearance of the term by Josh Backus in a MIT Summer Session
            (1954)
        \item
            Project to implement a time-sharing system started by John McCarthy
            at MIT (1959)
        \item Compatible Time-Sharing System, CTSS (1961)
    \end{itemize}
    \note{
        The concepts behind containers date back to the first time-sharing
        systems in the early days of modern computer history.}
\end{frame}

\begin{frame}
    \autotitle
    \begin{picture}(330, 200)
        \put(0, 0){
            \includegraphics[width=.45\linewidth]
                {img/advanced_coding_techniques0.jpg}}
        \only<2>{
            \put(25, 5){
                \includegraphics
                    [width=.90\linewidth]
                    {img/advanced_coding_techniques1.png}}}
    \end{picture}
\end{frame}

\begin{frame}
    \autotitle
    \begin{quote}
        Mr. P. F. Williams said that his firm is trying to decide on a
        computer to use.  They want something intermediate between an
        IBM 650 and 704.  The 704 seems too large: they would not be
        able to keep it busy.  Josh Backus said that by time sharing, a
        big computer could be used as several small ones; [...]
    \end{quote}
    Computer Advanced Coding Techniques, MIT Summer Session
    \cite{mit_summer_session}
    \note{
        This was in 1954, fifteen years before UNIX.  The basic concept,
        however, is still relevant.}
\end{frame}

\begin{frame}
    \autotitle
    \begin{quote}
        By allowing a large number of users to interact concurrently with a
        single computer, time-sharing dramatically lowered the cost of
        providing computing capability.  [...] While any single user would make
        inefficient use of a computer, a large group of users together would
        not.
    \end{quote}
    Wikipedia \cite{wikipedia_time_sharing}
\end{frame}

\subsection{history}

\subsubsection{chroot}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item \texttt{chroot(2)}
        \item Changes the root directory of the calling process
        \item Compartmentalize the filesystem
        \item Didn't provide any other isolation mechanisms
        \item Very trivial to "escape"
        \item The goal was not security
        \item Actually, no one really knows what the goal was
    \end{itemize}
\end{frame}

\begin{frame}
    \autotitle
    \begin{quote}
        [CHROOT]
        \\~\\
        Dr. Marshall Kirk Mckusick, private communication: "According to the
        SCCS logs, the chroot call was added by Bill Joy on March 18, 1982
        approximately 1.5 years before 4.2BSD was released.  That was well
        before we had ftp servers of any sort (ftp did not show up in the
        source tree until January 1983).  My best guess as to its purpose was
        to allow Bill to chroot into the /4.2BSD build directory and build a
        system using only the files, include files, etc contained in that tree.
        That was the only use of chroot that I remember from the early days."
    \end{quote}
    Poul-Henning Kamp, Robert Watson \cite{kamp_jails}
    \note{
        In 1975, Dennis Ritchie was a visiting professor at Berkeley, where he
        met Bill Joy, then a student.
        \\~\\
        From the work that was done at this period would result the Berkeley
        Software Distribution (BSD).
        \\~\\
        Bill Joy is the author of vi and csh, and in 1982 also co-founded of
        Sun Microsystems.}
\end{frame}

\subsubsection{jails}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item \texttt{jail(2)}
        \item Added to FreeBSD by Poul-Henning Kamp (1999)
        \item "Confining the omnipotent root"
        \item
            Created to address the problem of needing many machines, each
            almost idle, to have different versions of apache, mysql, perl etc.
        \item
            "Trivial extension" to \texttt{chroot(2)} to become "light-weight
            virtual 'machines'"
    \end{itemize}
\end{frame}

\begin{frame}
    \autotitle
    \begin{quote}
        The FreeBSD "Jail" facility provides the ability to partition the
        operating system environment, while maintaining the simplicity of the
        UNIX "root" model.  In Jail, users with privilege find that the scope
        of their requests is limited to the jail, allowing system
        administrators to delegate management capabilities for each virtual
        machine environment.
    \end{quote}
    Poul-Henning Kamp, Robert Watson \cite{kamp_jails}
\end{frame}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item "one-way mirror effect"
        \begin{itemize}
            \item
                unjailed processes can see jailed processes, send signals,
                attach debuggers, etc. (still subject to Unix access controls)
            \item
                jailed processes can't see or interact with processes outside,
                either unjailed or in other jails
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \autotitle
    \begin{quote}
        If somebody breaks into your computer, you face a nasty set of
        problems. For instance if you open a terminal connection, you may be
        talking to their special version of the sshd(8) daemon, and who knows
        what that does?
        \\~\\
        If you are running on perfectly virtualized servers, such as VMware,
        Xen or similar, you are as much subject to these problems as you are
        with dedicated hardware.
        \\~\\
        But if you put your outward facing services in a jail, you can
        comfortably log in using the unadultered sshd(8) in the unjailed part
        of the system, and see what the attackers are up to, while they cannot
        see you.
    \end{quote}
    Poul-Henning Kamp \cite{kamp_sagas_jails}
\end{frame}

\subsubsection{linux}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item Virtuozzo
        \begin{itemize}
            \item SWsoft, now Parallels (2000)
            \item originally proprietary
            \item
                switched to open-core (OpenVZ, GPL) model (2005) \cite{openvz}
        \end{itemize}
        \item Virtual private servers and security contexts
        \begin{itemize}
            \item Jacques Gélinas (2001) \cite{virtual_private_servers}
        \end{itemize}
        \item Linux-VServer
        \begin{itemize}
            \item Herbert Pötzl (2002) \cite{linux_vserver}
        \end{itemize}
        \item all require (to this day) a patched kernel
    \end{itemize}
\end{frame}

\subsubsection{zones}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item \texttt{zone(2)}
        \item Solaris 10 (2004)
        \item Proprietary, open-sourced (CDDL) as OpenSolaris (2005)
        \item Integrated at the operating system level
        \item Server consolidation
        \begin{itemize}
            \item namespace isolation
            \item security isolation
            \item quality of service guarantees
            \item account for resource utilization
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \autotitle
    \begin{quote}
        Managing zones is not complicated.  Figure 2 shows how to create a
        simple, non-networked zone called lisa with a file system hierarchy
        rooted at /aux0/lisa, install the zone, and boot it.  Booting a zone
        causes the init daemon for the zone to be launched.  At that point, the
        standard system services such as cron, sendmail, and inetd are
        launched.
    \end{quote}
    Daniel Price, Andrew Tucker \cite{solaris_zones}
\end{frame}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item Platform administrator vs. application administrator systems
        \item Installation
        \begin{itemize}
            \item package-manager aware
            \item packages can be managed from both the global and local zone
            \item reuses (copy or hard-link) files from the global zone
            \item
                sparse-root zones: \texttt{lofs} \texttt{/usr}, \texttt{/lib},
                \texttt{/sbin}, \texttt{/platform}
        \end{itemize}
        \item Branded zones
        \begin{itemize}
            \item syscall translation layer
            \item allows executing non-native binaries
            \item \texttt{solaris8}, \texttt{solaris9}, \texttt{lx}
        \end{itemize}
    \end{itemize}
\end{frame}

\subsection{technologies}

\begin{frame}
    \autotitle
    container != vm != lxc != docker
    \note{
        Containers and virtual machines are usually compared as "just two types
        virtualization techniques", but have fundamental differences that have
        to be evaluated when considering their application.
        \\~\\
        There is even confusion as to what containers are exactly.  It doesn't
        help that there is a project called "linux containers" (abbreviated
        "lxc") that is an implementation of containers.  Another common
        misconception is that containers started with (or even that they are
        limited or equal to) docker.
        \\~\\
        Containers are not a new technology.  The ideia was born in 2005 on the
        Solaris operating system from Sun Microsystems and still lives in
        OpenSolaris and BSD derivatives.  They aren't even a new technology in
        Linux: most of the tools used to implement containers have been part of
        the system since the last decade.
    }
\end{frame}

\subsubsection{container}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item a process or group of processes
        \item
            executing on the same kernel (\textit{i.e. kernel not virtualized})
        \item
            with different levels of isolation from other processes and kernel
            resources
    \end{itemize}
\end{frame}

\begin{frame}
    \autotitle
    \begin{quote}
        Virtualization is an euphemism for "pathological lying".
    \end{quote}
    Bryan Cantrill
\end{frame}

\begin{frame}[fragile]
    \autotitle
    No virtualization:
    \begin{figure}
        \centering
        \begin{varwidth}{\linewidth}
            \begin{verbatim}
 -----------------------------
| process   process   process |
|-----------------------------|
|           kernel            |
|-----------------------------|
|          hardware           |
 -----------------------------
            \end{verbatim}
        \end{varwidth}
    \end{figure}
    \note{
        With no virtualization, processes that want to talk to the hardware or
        to other processes just do it: the only limitations are file
        permissions, capabilities, etc.
    }
\end{frame}

\begin{frame}[fragile]
    \autotitle
    Hardware-level virtualization:
    \begin{figure}
        \centering
        \begin{varwidth}{\linewidth}
            \begin{verbatim}

 --- vm ---   ------- vm --------
| process  | | process   process |
|----------| |-------------------|
| guest os | |     guest os      |
|----------| |-------------------|
| hardware | |     hardware      |
|--------------------------------|
|           hypervisor           |
|--------------------------------|
|             kernel             |
|--------------------------------|
|            hardware            |
 --------------------------------
            \end{verbatim}
        \end{varwidth}
    \end{figure}
    \note{
        Hardware-level virtualization emulates the hardware of a physical
        machine and runs another operating system inside it.  Management of the
        guests and access to the host's hardware or to other guests is handled
        by a process on the host, called the "hypervisor".
        \\~\\
        Requests from the guests to the (virtual) hardware are trapped by the
        hypervisor, which has to maintain the "illusion" that they are
        executing on real machines.
    }
\end{frame}

\begin{frame}[fragile]
    \autotitle
    Containers (OS-level virtualization):
    \begin{figure}
        \centering
        \begin{varwidth}{\linewidth}
            \begin{verbatim}
 - container -   ---- container ----
|   process   | | process   process |
|-----------------------------------|
|              kernel               |
|-----------------------------------|
|             hardware              |
 -----------------------------------
            \end{verbatim}
        \end{varwidth}
    \end{figure}
    \note{
        OS-level virtualization doesn't involve any emulation: when a process
        talks to the hardware, it is talking to the real hardware.  The kernel
        provides tools to limit how much of the system is available to be used
        by the containers.
    }
\end{frame}

\begin{frame}
    \autotitle
    \centering
    \only<1>{
        \includegraphics[width=1\linewidth]
            {img/docker_diagram_kernel.png}
    }
    \only<2>{
        \includegraphics[width=0.8\linewidth]
            {img/the-linux-programming-interface.jpg}
    }
    \only<3>{
        \includegraphics[width=1\linewidth]
            {img/docker-execdriver-diagram.png}
    }
    \note<1>{
        Most of the tools that are used to implement containers have been in
        the kernel for years.
    }
    \note<2>{
        But those are low-level tools that require some level of systems
        programming.
    }
    \note<3>{
        The change that led to the recent popularization of containers was the
        development of systems that make use of these tools while providing a
        user (or developer) interface that is much simpler, inspired by web
        application development.  Dotcloud, before becoming Docker, was a PaaS
        company.
    }
\end{frame}

\subsection{pros-cons}

\subsubsection{pros}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item new and highly expanding technologies
        \item shared kernel
            \begin{itemize}
                \item hardware is not virtualized
                \begin{itemize}
                    \item smaller overhead
                    \item smaller resource utilization
                \end{itemize}
                \item faster initialization (\textit{ms})
                \item single update
                    (\textit{kpatch}/\textit{ksplice}/\textit{live patching}?)
            \end{itemize}
    \end{itemize}
\end{frame}

\subsubsection{cons}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item new and highly expanding technologies
        \item shared kernel
        \begin{itemize}
            \item hardware is not virtualized
            \item only one type
            \begin{itemize}
                \item version
                \item architecture
                \item operating system
            \end{itemize}
            \item kernel exploits
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \autotitle
    \begin{quote}
        There’s an additional advantage to containerizing your application. It
        forces you to think hard about configuration, limiting the amount of
        mutable state inside your environment and your ability to scale
        horizontally.
        \\~\\
        An exercise in switching to container-based deploys is actually an
        exercise in good engineering practices and any extra work required by
        Docker pays off by making your codebase better factored and less
        brittle.
    \end{quote}
    Jan Urbański - New Relic
\end{frame}

\section{implementation}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item cgroups
        \item namespaces
    \end{itemize}
\end{frame}

\subsection{cgroups}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item linux 2.6.24 (2007)
        \item resource limiting/reservation
        \item accounting/auditing
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \autotitle
    \verb|awk 'NR>1{print$1}' /proc/cgroups|
    \begin{multicols}{3}
        \begin{itemize}
            \item cpuset
            \item cpu
            \item cpuacct
            \item blkio
            \item memory
            \item devices
            \item freezer
            \item net\_cls
            \item pids
        \end{itemize}
    \end{multicols}
\end{frame}

\begin{frame}[fragile]
    \autotitle
    \begin{verbatim}
$ awk '/cgroup/{sub(".*,","",$4);print$2,$3,$4}' /proc/mounts
/sys/fs/cgroup tmpfs mode=755
/sys/fs/cgroup/systemd cgroup name=systemd
/sys/fs/cgroup/blkio cgroup blkio
/sys/fs/cgroup/cpu,cpuacct cgroup cpuacct
/sys/fs/cgroup/net_cls cgroup net_cls
/sys/fs/cgroup/pids cgroup pids
/sys/fs/cgroup/cpuset cgroup cpuset
/sys/fs/cgroup/devices cgroup devices
/sys/fs/cgroup/freezer cgroup freezer
/sys/fs/cgroup/memory cgroup memory
    \end{verbatim}
\end{frame}

\subsubsection{cpuset}

\begin{frame}[fragile]
    \autotitle
    \begin{itemize}
        \item \verb|cat /sys/fs/cgroup/cpuset/cpuset.mems|
        \item \verb|echo 0-1 > /sys/fs/cgroup/cpuset/cpuset.mems|
        \item \verb|cat /sys/fs/cgroup/cpuset/cpuset.cpus|
        \item \verb|echo 3-5 > /sys/fs/cgroup/cpuset/cpuset.cpus|
    \end{itemize}
\end{frame}

\subsubsection{cpu}

\begin{frame}[fragile]
    \autotitle
    \begin{itemize}
        \item \verb|cat /sys/fs/cgroup/cpu/cpu.shares|
        \item \verb|echo 1024 > /sys/fs/cgroup/cpu/cpu.shares|
    \end{itemize}
\end{frame}

\subsubsection{cpuacct}

\begin{frame}[fragile]
    \autotitle
    \begin{itemize}
        \item \verb|cat /sys/fs/cgroup/cpuacct/cpuacct.stat|
        \item \verb|cat /sys/fs/cgroup/cpuacct/cpuacct.usage|
        \item \verb|cat /sys/fs/cgroup/cpuacct/cpuacct.usage_percpu|
    \end{itemize}
\end{frame}

\subsubsection{blkio}

\begin{frame}[fragile]
    \autotitle
    \verb!ls /sys/fs/cgroup/blkio/blkio.* | grep -v '_recursive'!
    \begin{multicols}{2}
        \begin{itemize}
            \item blkio.io\_merged
            \item blkio.io\_queued
            \item blkio.io\_service\_bytes
            \item blkio.io\_serviced
            \item blkio.io\_service\_time
            \item blkio.io\_wait\_time
            \item blkio.leaf\_weight
            \item blkio.leaf\_weight\_device
            \item blkio.reset\_stats
            \item blkio.sectors
            \item blkio.throttle.io\_service\_bytes
            \item blkio.throttle.io\_serviced
            \item blkio.throttle.read\_bps\_device
            \item blkio.throttle.read\_iops\_device
            \item blkio.throttle.write\_bps\_device
            \item blkio.throttle.write\_iops\_device
            \item blkio.time
            \item blkio.weight
            \item blkio.weight\_device
        \end{itemize}
    \end{multicols}
\end{frame}

\subsubsection{memory}

\begin{frame}[fragile]
    \autotitle
    \begin{itemize}
        \item \verb|cat /sys/fs/cgroup/memory/memory.usage_in_bytes|
        \item \verb|cat /sys/fs/cgroup/memory/memory.limit_in_bytes|
        \item \verb|echo $x > /sys/fs/cgroup/memory/memory.limit_in_bytes|
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \autotitle
    \verb|awk '!/^total_/{print$1}' /sys/fs/cgroup/memory/memory.stat|
    \begin{multicols}{2}
        \begin{itemize}
            \item cache
            \item rss
            \item rss\_huge
            \item mapped\_file
            \item dirty
            \item writeback
            \item swap
            \item pgpgin
            \item pgpgout
            \item pgfault
            \item pgmajfault
            \item inactive\_anon
            \item active\_anon
            \item inactive\_file
            \item active\_file
            \item unevictable
            \item hierarchical\_memory\_limit
            \item hierarchical\_memsw\_limit
        \end{itemize}
    \end{multicols}
\end{frame}

\subsubsection{devices}

\begin{frame}[fragile]
    \autotitle
    \begin{itemize}
        \item \verb|cat /sys/fs/cgroup/devices/devices.list|
        \item \verb|echo 'a *:* rwm' > /sys/fs/cgroup/devices/devices.allow|
        \item \verb|echo a > /sys/fs/cgroup/devices/devices.deny|
    \end{itemize}
\end{frame}

\subsubsection{freezer}

\begin{frame}[fragile]
    \autotitle
    \begin{itemize}
        \item \verb|cat /sys/fs/cgroup/$child/freezer.state|
        \item \verb|echo FROZEN> /sys/fs/cgroup/$child/freezer.state|
        \item \verb|echo THAWED > /sys/fs/cgroup/$child/freezer.state|
    \end{itemize}
\end{frame}

\subsubsection{net\_cls}

\begin{frame}[fragile]
    \autotitle
    \begin{itemize}
        \item \verb|cat /sys/fs/cgroup/net_cls/net_cls.classid|
        \item \verb|maj=0001; min=0001; cls=0x$maj$min|
        \item \verb|echo $cls > /sys/fs/cgroup/net_cls/net_cls.classid|
    \end{itemize}
\end{frame}

\subsubsection{pid}

\begin{frame}[fragile]
    \autotitle
    \begin{itemize}
        \item \verb|cat /sys/fs/cgroup/pids/pids.current|
        \item \verb|echo 2 > /sys/fs/cgroup/pids/pids.max|
    \end{itemize}
\end{frame}

\subsection{namespaces}

\begin{frame}
    \autotitle
    \begin{itemize}
        \only<1>{
            \item \texttt{unshare(2)}
            \item \texttt{clone(2)}
            \item \texttt{setns(2)}
        }
        \only<2>{
            \item mnt (\texttt{CLONE\_NEWNS})
            \item uts (\texttt{CLONE\_NEWUTS})
            \item ipc (\texttt{CLONE\_NEWIPC})
            \item pid (\texttt{CLONE\_NEWPID})
            \item net (\texttt{CLONE\_NEWNET})
            \item uid (\texttt{CLONE\_NEWUSER})
        }
    \end{itemize}
    \note<1>{
        Namespaces are an isolation facility provided by the kernel.  They are
        at the core of containers and are responsible for the isolation that
        allows processes to execute on the same machine without interfering
        with each other.
        \\~\\
        Namespaces can be manipulated using three system calls:
        \begin{itemize}
            \item
                \texttt{unshare(2)} creates a namespace and associates the
                process to it.
            \item
                \texttt{clone(2)} is similar to a \texttt{fork(2)} followed by
                an \texttt{unshare(2)}.
            \item
                \texttt{setns(2)} associates a process with an existing
                namespace.
        \end{itemize}
    }
    \note<2>{
        Each of this syscalls takes a \texttt{flag} argument which includes
        these values for selecting which namespace(s) should created/joined.
    }
\end{frame}

\subsubsection{mount}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item \texttt{CLONE\_NEWNS}
        \item linux 2.4.19 (2002)
        \item \texttt{mount(2)/umount(2)}
        \item different processes have different visions of the file system
        \item ``\texttt{chroot(2)} on steroids''
        \item sharing of mount points
    \end{itemize}
\end{frame}

\subsubsection{uts}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item \texttt{CLONE\_NEWUTS}
        \item linux 2.6.19 (2006)
        \item \texttt{uname(2)}
        \item \texttt{sethotname(2)}
        \item \texttt{setdomainname(2)}
        \item Unix Timesharing System
    \end{itemize}
\end{frame}

\subsubsection{ipc}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item \texttt{CLONE\_NEWIPC}
        \item linux 2.6.19 (2006) / linux 2.6.30 (2009)
        \item \texttt{svipc(7)}/\texttt{mq\_overview(7)}
        \item isolation for the 32-bit resource ids
        \item
            sysV IPC has been mostly superseded, but some programs (e.g.
            postgresql) still use it
    \end{itemize}
\end{frame}

\subsubsection{pid}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item \texttt{CLONE\_NEWPID}
        \item linux 2.6.24 (2008)
        \item each pid inside a namespace is mapped to a pid outside
        \item the same pid may appear on different namespaces
        \item processes don't see processes of other namespaces
        \item
            offers protection from pid-based syscalls like \texttt{kill(2)},
            \texttt{ptrace(2)}, etc
        \item
            \texttt{procfs} only shows information related to processes on the
            namespace
        \item migration between hosts
        \item each namespace has its own pid 1
        \item
            can be nested: a parent namespace can see and affect processes on
            child namespaces; processes on a child namespace don't see and
            can't do anything to processes on the parent
    \end{itemize}
\end{frame}

\subsubsection{net}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item \texttt{CLONE\_NEWNET}
        \item linux 2.6.24 (2008)
        \item each namespace has its own
            \begin{itemize}
                \item network devices (including \texttt{lo})
                \item ip addresses
                \item routing tables
                \item \texttt{/proc/net}
                \item ports
                \item etc.
            \end{itemize}
        \item
            communication with the host or with other namespaces can be
            implemented using \texttt{veth} pairs and/or bridge interfaces
        \item
            \texttt{INADDR\_ANY} (a.k.a. \texttt{0.0.0.0}) means "any address
            on the current namespace"
    \end{itemize}
\end{frame}

\subsubsection{user}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item \texttt{CLONE\_NEWUSER}
        \item linux 2.6.23 (2007)
        \item finalized on kernel 3.8 (2013) $->$ $\sim$ five years
        \item uid and gid isolation and mapping
        \item \texttt{uid 0}
        \item recursive
        \begin{itemize}
            \item an unprivileged process can create a namespace
            \item \texttt{uid 0} inside the namespace
            \item<2> ö
        \end{itemize}
    \end{itemize}
\end{frame}

\subsubsection{demo}

\begin{frame}[fragile]
    \autotitle
    \begin{semiverbatim}
        \only<1>{
# create containers
./ns_test
# create pairs of veths
ip link add h1 type veth peer name c1
ip link add h2 type veth peer name c2
# move one to each container's namespace
ip link set dev c1 netns /proc/$pid1/ns/net
ip link set dev c2 netns /proc/$pid2/ns/net
# rename each container's veth to eth0
nsenter --net --target $pid1 ip link set dev c1 name eth0
nsenter --net --target $pid2 ip link set dev c2 name eth0
        }
        \only<2>{
# assign addresses to each container's interfaces
nsenter -n -t $pid1 ip addr add 10.0.0.2/8 dev eth0
nsenter -n -t $pid2 ip addr add 10.0.0.3/8 dev eth0
nsenter -n -t $pid1 ip set eth0 up
nsenter -n -t $pid2 ip set eth0 up
ip link set h1 up
ip link set h2 up
# create a bridge and add the containers' interfaces
brctl addbr br0
brctl addif br0 h1 h2
        }
    \end{semiverbatim}
    \note<1>{
        This demo shows how multiple network namespaces can all be connected.
        Outside the namespaces, for each container:
        \begin{itemize}
            \item a pair of \texttt{veth}'s is created
            \item one of the endpoints is moved to the network namespace
            \item the interface name inside the namespace is changed to "eth0"
            \item an address is assigned to it
        \end{itemize}
        Finally, a bridge interface is created and the other endpoints of all
        the pairs are added to it.  This bridge routes packets coming from/to
        the veth pairs as if they were connected by a layer 2 hub.
    }
\end{frame}

\begin{frame}[fragile]
    \autotitle
    \begin{figure}
        \centering
        \begin{varwidth}{\linewidth}
            \begin{verbatim}
 -- container0 --   -- container1 --
|      eth0      | |      eth0      |
 --------|-------   --------|-------
         |                  |
 --------|------ br0 -------|-------
|        h1                 h2      |
 -----------------------------------
            \end{verbatim}
        \end{varwidth}
    \end{figure}
\end{frame}

\section{security}

\subsection{root}

\begin{frame}
    \autotitle
    \only<1>{
        \begin{itemize}
            \item don't use
        \end{itemize}
    }
    \only<2>{
        \begin{quote}
            For repos we recognize on or after 2015-01-01, linux builds are
            sent to our container-based infrastructure.
        \end{quote}
        Travis CI
    }
    \only<3>{
        \begin{quote}
            This job is running on container-based infrastructure, which
            does not allow use of 'sudo', setuid and setguid executables.
            If you require sudo, add 'sudo: required' to your .travis.yml
        \end{quote}
        Travis CI
    }
\end{frame}

\subsection{applications}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item
            Most containers execute a specific task, instead of a complete
            system, and most applications (\textit{apache}, \textit{nginx},
            \textit{postgresql}, \textit{redis}, ...) don't need \textit{root}
            privileges.
        \item
            The risks are the same as before: assume the application can do
            anything to escape isolation.
    \end{itemize}
\end{frame}

\begin{frame}
    \autotitle
    \only<1>{
        syscalls
        \begin{itemize}
            \item e.g. \texttt{vmsplice(2)}
            \item limits the \textit{syscalls} available
            \item seccomp/seccomp-bpf
            \item \texttt{capabilities(7)}
            \item \texttt{selinux(8)}/\texttt{apparmor(7)}
            \item grsec
            \item constant updates
        \end{itemize}
        = reduce kernel exposure
    }
    \only<2>{
        \begin{quote}
            ``[...] there's maybe marginal increases in practical security for
            certain kinds of deployment, and perhaps marginal decreases for
            others.  We end up coming back to the attack surface, and it seems
            inevitable that that's always going to be larger in container
            environments. The question is, does it matter? If the larger attack
            surface still only results in one more vulnerability per thousand
            years, you probably don't care. The aim isn't to get containers to
            the same level of security as hypervisors, it's to get them close
            enough that the difference doesn't matter.''
        \end{quote}
        Matthew Garrett
    }
    \note<1>{
        The big difference in the surface of attack between virtual machines
        and containers is the kernel.  On a virtual machine, an attacker that
        is able to exploit the (guest) kernel still has to break out to the
        hypervisor.  Since containers share the same kernel, an exploit gives
        direct access to the system.
        \\~\\
        Since the interface to the kernel is the system calls, a big part in
        securing containers involves hardening them.  Although kernel exploits
        are rare, they exist: the \texttt{vmsplice} one is a recent example.
        Limiting the syscalls available can be done using the \texttt{seccomp}
        family of syscalls.  Capabilities, selinx and apparmor reduce the
        impact of an exploit by clearly delimiting the actions a process can
        take.  The grsec kernel is a series of out-of-tree patches that
        prioritize security.
    }
\end{frame}

\section{references}

\begin{frame}
    \begin{quote}
        These two papers are important because they don't just capture what was
        done, but why it was done.  This is really, really, really important.
        And if you are working on an important technology, please do this.
        Because when we don't have it, we have javascript.
    \end{quote}
    Bryan Cantrill \cite{cantrill_jails_zones}
\end{frame}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item
            \href
                {https://blog.newrelic.com/2015/06/18/zero-to-docker/}
                {Zero to docker}
        \item
            \href
                {https://www.kernel.org/doc/Documentation/cgroups-v1/}
                {cgroups docs}
        \item
            \href
                {https://www.kernel.org/doc/Documentation/cgroups-v2.txt}
                {cgroups-v2 docs}
        \item
            \href
                {https://lwn.net/Articles/531114/}
                {Namespaces in operation}
        \item
            \href
                {http://mjg59.dreamwidth.org/33170.html}
                {Linux Container Security}
        \item
            \href
                {http://www.slideshare.net/jpetazzo/docker-linux-containers-lxc-and-security}
                {Docker, Linux Containers (LXC), and security}
        \item
            \href
                {https://lwn.net/Articles/268783/}
                {vmsplice(): the making of a local root exploit}
        \item
            \href
                {https://www.youtube.com/watch?v=0T2XFSALOaU}
                {Docker in Production: Tales From the Engine Room [video]}
    \end{itemize}
\end{frame}

\begin{frame}
    \autotitle
    \begin{itemize}
        \item
            \href
                {http://www.servicioswebgratis.com/wp-content/uploads/2012/08/the-linux-programming-interface.jpg}
                {The Linux Programming Interface}
        \item
            \href
                {http://blog.docker.com/2014/03/docker-0-9-introducing-execution-drivers-and-libcontainer/}
                {Docker drivers}
    \end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]
    \autotitle
    \begin{thebibliography}{10}
        \bibitem{kamp_varnish}
            \href
                {https://www.varnish-cache.org/news/20160425_website.html}
                {Varnish - How our website works}
        \bibitem{mit_summer_session}
            \href
                {http://bitsavers.org/pdf/mit/summer_session_1954/Digital_Computers_Advanced_Coding_Techniques_Summer_1954.pdf}
                {MIT - Computer Advanced Coding Techniques}
        \bibitem{wikipedia_time_sharing}
            \href
                {https://en.wikipedia.org/wiki/Time-sharing}
                {Wikipedia - Time-sharing}
        \bibitem{kamp_jails}
            \href
                {http://phk.freebsd.dk/pubs/sane2000-jail.pdf}
                {Jails: Confining the omnipotent root}
        \bibitem{kamp_sagas_jails}
            \href
                {http://phk.freebsd.dk/sagas/jails.html}
                {Jails: High value but shitty Virtualization}
        \bibitem{openvz}
            \href
                {https://openvz.org}
                {OpenVZ}
        \bibitem{virtual_private_servers}
            \href
                {http://www.solucorp.qc.ca/miscprj/s_context.hc}
                {Virtual private servers and security contexts}
        \bibitem{linux_vserver}
            \href
                {http://linux-vserver.org/Paper}
                {Linux-VServer}
        \bibitem{solaris_zones}
            \href
                {https://www.usenix.org/event/lisa04/tech/full_papers/price/price.pdf}
                {Daniel Price, Andrew Tucker - Solaris Zones: Operating System
                    Support for Consolidating Commercial Workloads}
        \bibitem{cantrill_jails_zones}
            \href
                {https://www.youtube.com/watch?v=hgN8pCMLI2U}
                {Bryan Cantrill - Jails and Solaris Zones}
    \end{thebibliography}
\end{frame}

\end{document}
